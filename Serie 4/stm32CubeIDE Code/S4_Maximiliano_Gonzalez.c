 /**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdint.h>

//PERIPHERAL & BUS BASE ADDRESS
#define PERIPHERAL_BASE_ADDRESS 0x40000000U
#define AHB_BASE_ADDRESS (PERIPHERAL_BASE_ADDRESS + 0x00020000U)

//RCC BASE ADDRESS
#define RCC_BASE_ADDRESS (AHB_BASE_ADDRESS + 0x00001000U)
#define RCC_IOPENR_ADDRESS (RCC_BASE_ADDRESS + 0x0000002CU)

//IOPORT BASE ADDRESS
#define IOPORT_ADDRESS (PERIPHERAL_BASE_ADDRESS + 0x10000000U)

//GPIOA BASE & SPECIFIC ADDRESS
#define GPIOA_BASE_ADDRESS (IOPORT_ADDRESS + 0x00000000U)

//GPIOB BASE & SPECIFIC ADRESS
#define GPIOB_BASE_ADDRESS (IOPORT_ADDRESS + 0x00000400U)


//GPIOC BASE & SPECIFIC ADRESS
#define GPIOC_BASE_ADDRESS (IOPORT_ADDRESS + 0x00000800U)


typedef struct {

	uint32_t MODER;
	uint32_t OTYPER;
	uint32_t OSPEEDR;
	uint32_t PUPDR;
	uint32_t IDR;
	uint32_t ODR;
	uint32_t BSRR;
	uint32_t LCKR;
	uint32_t AFR[2];
	uint32_t BRR;

} GPIOx_REG_DEF;

#define GPIOA ((GPIOx_REG_DEF*)GPIOA_BASE_ADDRESS)
#define GPIOB ((GPIOx_REG_DEF*)GPIOB_BASE_ADDRESS)
#define GPIOC ((GPIOx_REG_DEF*)GPIOC_BASE_ADDRESS)

typedef struct {

	uint32_t CR;
	uint32_t ICSR;
	uint32_t CRRCR;
	uint32_t CFGR;
	uint32_t CIER;
	uint32_t CIFR;
	uint32_t CICR;
	uint32_t IOPRSTR;
	uint32_t AHBPRSTR;
	uint32_t APB1PRSTR;
	uint32_t APB2PRSTR;
	uint32_t IOPENR;


}RCC_REG_DEF;

#define RCC ((RCC_REG_DEF*)RCC_BASE_ADDRESS)

//Enable ports
#define D3_CTRL (1U<<5) //PORTC POS5
#define D2_CTRL (1U<<6) //PORTC POS6
#define D1_CTRL (1U<<8) //PORTC POS8
#define D0_CTRL (1U<<9) //PORTC POS9

//Clear display segments
#define ALL_DISPLAY_CTRL (D3_CTRL | D2_CTRL | D1_CTRL | D0_CTRL)

//Bits used for output
#define ca_cc_bits 0xFF

//Decimal Point
#define SEG_DP (1U<<7)

//Tests
#define SCAN_DELAY_MS 1 //Display scan delay
#define FAKE_SEC_MS 3 //Time speed

//Alarm
#define Alarm_LED_Pin  (1U<<5) //PORTA POS5
#define Alarm_BLINK_RATE 250

//Alarm BTN
#define ACK_PIN (1U<<6) // PORTA POS6

//Mode Switch
#define DEBOUNCE_MS 20
#define LEADING_ZERO_12H 0

//Mode Changer
uint8_t mode24 = 1;

//Mode Change Global Variables
uint8_t btnStable = 0;
uint16_t btnDebMs = 0;

//Alarm BTN Global Variables
uint8_t ackStable = 1;
uint16_t ackDebMS = 0;

//Alarm Global Variables
uint8_t  alarm_ringing = 0;
uint8_t  alarm_led_on  = 0;
uint16_t alarmBlinkAcc = 0;

//BTN DEBOUNCE LOGIC
void modeSW_tick(void) {

	uint8_t rawBTNPress = (GPIOC->IDR & (1U<<13)) ? 1 : 0;
	if(rawBTNPress != btnStable) {
		btnDebMs += SCAN_DELAY_MS;
		if(btnDebMs >= DEBOUNCE_MS) {
			btnStable = rawBTNPress;
			btnDebMs = 0;

			if(btnStable == 1) {
				mode24 ^= 1;
			}
		}
	} else {
		btnDebMs = 0;
	}
}

//Stop Alarm BTN
void alarmBtn(void) {
	uint8_t rawBTNPress = (GPIOA->IDR & ACK_PIN) ? 1 : 0;
	if(rawBTNPress != ackStable) {
		ackDebMS += SCAN_DELAY_MS;
		if(ackDebMS >= DEBOUNCE_MS) {
			ackStable = rawBTNPress;
			ackDebMS = 0;
			if(ackStable == 0 && alarm_ringing) {
				alarm_ringing = 0;

				GPIOA->BSRR = (Alarm_LED_Pin<<16);
				alarm_led_on = 0;
			}
		}
	} else {
		ackDebMS = 0;
	}
}

//Function Declarations
void delay_ms(uint16_t n);
uint8_t parser (uint8_t decoder);

//Clock FSM
uint8_t my_fsm = 0x00;

//Time Variables
struct timeVar {

	uint8_t seconds_U;
	uint8_t seconds_D;
	uint8_t minutes_U;
	uint8_t minutes_D;
	uint8_t hours_U;
	uint8_t hours_D;

};

//Time Tracker
uint16_t timeTracker = 0;

int main(void) {

	//Enable Clock GPIOA
	RCC->IOPENR |= 1 <<0;
	//Enable Clock GPIOB
	RCC->IOPENR |= 1 <<1;
	//Enable Clock GPIOC
	RCC->IOPENR |= 1 <<2;

	//GPIOA PORT CONFIG
	GPIOA->MODER = (GPIOA->MODER & ~(3U<<(2*5))) | (1U<<(2*5));//GPIOA5
	GPIOA->MODER &= ~(3U<<(2*6));//GPIOA6
	GPIOA->PUPDR = (GPIOA->PUPDR & ~(3U << (2*6))) | (1U << (2*6));

	//GPIOB PORT CONGIC, ALL OUTPUTS
	GPIOB->MODER = (GPIOB->MODER & ~(3U<<(2*0))) | (1U<<(2*0));//GPIOB0
	GPIOB->MODER = (GPIOB->MODER & ~(3U<<(2*1))) | (1U<<(2*1));//GPIOB1
	GPIOB->MODER = (GPIOB->MODER & ~(3U<<(2*2))) | (1U<<(2*2));//GPIOB2
	GPIOB->MODER = (GPIOB->MODER & ~(3U<<(2*3))) | (1U<<(2*3));//GPIOB3
	GPIOB->MODER = (GPIOB->MODER & ~(3U<<(2*4))) | (1U<<(2*4));//GPIOB4
	GPIOB->MODER = (GPIOB->MODER & ~(3U<<(2*5))) | (1U<<(2*5));//GPIOB5
	GPIOB->MODER = (GPIOB->MODER & ~(3U<<(2*6))) | (1U<<(2*6));//GPIOB6
	GPIOB->MODER = (GPIOB->MODER & ~(3U<<(2*7))) | (1U<<(2*7));//GPIOB7


	//GPIOC PORT CONFIG, Display EN Output
	GPIOC->MODER = (GPIOC->MODER & ~(3U<<(2*5))) | (1U<<(2*5));//GPIOC5
	GPIOC->MODER = (GPIOC->MODER & ~(3U<<(2*6))) | (1U<<(2*6));//GPIOC6
	GPIOC->MODER = (GPIOC->MODER & ~(3U<<(2*8))) | (1U<<(2*8));//GPIOC8
	GPIOC->MODER = (GPIOC->MODER & ~(3U<<(2*9))) | (1U<<(2*9));//GPIOC9

	//GPIOC PORT CONFIC, BTN Input
	GPIOC->MODER &= ~(3U<<(2*13));//GPIOC13
	GPIOC->PUPDR &= ~(3U<<(2*13));//Internal Pull down

	//PWR ON, Clear Displays
	GPIOC->BSRR = (ALL_DISPLAY_CTRL<<16);

	//Force 00:00 at PWR ON
	btnStable = (GPIOC->IDR & (1U<<13)) ? 1 : 0;
	btnDebMs = 0;

	//Clock & Alarms Time Variable Structure
	struct timeVar clock = {0,0, 0,0, 0,0};
	struct timeVar alarm = {0,0, 0,0, 1,0};


	while(1) {

		//24h to 12h conversion
		int h24 = clock.hours_D*10 + clock.hours_U;
		int dispH = h24;
		if(!mode24) {
			if(dispH == 0) {
				dispH = 12;
			} else if(dispH > 12) {
				dispH -= 12;
			}
		}
		uint8_t dispHD = dispH / 10;
		uint8_t dispHU = dispH % 10;

		modeSW_tick();
		alarmBtn();

		switch(my_fsm) {

			//print M U
			case 0: {

				GPIOC->BSRR = (ALL_DISPLAY_CTRL << 16); //Turn off previous display
				GPIOB->BSRR = ca_cc_bits<<16; //Clear previous value
				GPIOC->BSRR = D0_CTRL; //Turn on current display
				GPIOB->BSRR = parser(clock.minutes_U); //Print display value

				my_fsm = 1;
				break;
			}

			//print M D
			case 1: {

				GPIOC->BSRR = (ALL_DISPLAY_CTRL << 16); //Turn off previous display
				GPIOB->BSRR = ca_cc_bits<<16;
				GPIOC->BSRR = D1_CTRL;
				GPIOB->BSRR = parser(clock.minutes_D);
				my_fsm = 2;
				break;
			}

			//print H U
			case 2:{

				GPIOC->BSRR = (ALL_DISPLAY_CTRL << 16); //Turn off previous display
				GPIOB->BSRR = ca_cc_bits<<16; //Clear previous value
				GPIOC->BSRR = D2_CTRL; //Turn on current display
				GPIOB->BSRR = parser(dispHU) | SEG_DP; //Print values

				my_fsm = 3;
				break;
			}

			//print H D
			case 3:{

				GPIOC->BSRR = (ALL_DISPLAY_CTRL << 16); //Turn off previous display
				GPIOB->BSRR = ca_cc_bits<<16; //Clear previous value
				GPIOC->BSRR = D3_CTRL; //Turn on current display
				uint8_t tensMask = (!mode24 && dispHD==0 && !LEADING_ZERO_12H) ? 0 : parser(dispHD);
				GPIOB->BSRR = tensMask;

				my_fsm = 0x00;
				break;
			}
			default: {
				my_fsm = 0x00;
				break;
			}
		}

		delay_ms(SCAN_DELAY_MS);
		timeTracker += SCAN_DELAY_MS;
		alarmBlinkAcc += SCAN_DELAY_MS;

		if(timeTracker >= FAKE_SEC_MS) {

			timeTracker = 0x0000;
			clock.seconds_U++;

			if(clock.seconds_U > 9) {

				clock.seconds_D++;
				clock.seconds_U = 0x00;

				if(clock.seconds_D > 5) {

					clock.minutes_U++;
					clock.seconds_D = 0x00;

					if(clock.minutes_U > 9) {

						clock.minutes_D++;
						clock.minutes_U = 0x00;

						if(clock.minutes_D > 5) {

							clock.minutes_D = 0x00;
							int h = clock.hours_D*10 + clock.hours_U;
							h+=1;
							if(h >= 24) {
								h = 0;
							}
							clock.hours_D = h/10;
							clock.hours_U = h%10;
						}
					}
				}
			}

		      //Alarm Trigger
		      if (!alarm_ringing) {
		        if (clock.seconds_U == alarm.seconds_U && clock.seconds_D == alarm.seconds_D &&
		            clock.minutes_U == alarm.minutes_U && clock.minutes_D == alarm.minutes_D &&
		            clock.hours_U   == alarm.hours_U   && clock.hours_D   == alarm.hours_D) {
		          alarm_ringing = 1;
		        }
		      }
		    }

		    //Alarm LED Trigger
		    if (alarm_ringing) {
		      if (alarmBlinkAcc >= Alarm_BLINK_RATE) {
		        alarmBlinkAcc = 0;
		        if (alarm_led_on) {
		          GPIOA->BSRR = (Alarm_LED_Pin << 16);  // OFF
		          alarm_led_on = 0;
		        } else {
		          GPIOA->BSRR = (Alarm_LED_Pin);        // ON
		          alarm_led_on = 1;
		        }
		      }
		    } else {
		      if (alarm_led_on) {
		        GPIOA->BSRR = (Alarm_LED_Pin << 16);
		        alarm_led_on = 0;
		      }
		}
	}
}

//Delay Function
void delay_ms(uint16_t n) {
	uint16_t i;
	for(; n>0; n--)
		for(i=0; i<140; i++);
}

//LED decoder
uint8_t parser (uint8_t decoder) {
	switch(decoder) {

		case 0: return 0b0111111;
		case 1: return 0b0000110;
		case 2: return 0b1011011;
		case 3: return 0b1001111;
		case 4: return 0b1100110;
		case 5: return 0b1101101;
		case 6: return 0b1111101;
		case 7: return 0b0000111;
		case 8: return 0b1111111;
		case 9: return 0b1101111;
		default: return 0;

	}
}
